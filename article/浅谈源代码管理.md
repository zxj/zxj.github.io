#浅谈源代码管理

`SCM`(Source Code Management)源代码管理，也有人把类似的事情叫做`VCS`(Version Control System)版本控制系统。

##源代码管理的场景描述
下面通过一个场景故事给大家源代码管理过程中的细节。

**背景**：新员工小菜的第一个开发任务

**场景**：办公室

**人物**：小菜、老鸟、攀哥

*老鸟*：走到小菜跟前说：小菜，昨天给你讲那个需求理解了么？

*小菜*：理解了。

*老鸟*：嗯，好，我现在给你讲一下我们实际工作中的代码管理方式，然后你就可以开工了。

*小菜*：嗯，太好了，我正发愁无从下手呢！

*老鸟*：我们的代码管理工具用的是`TFS`内置的代码管理功能，昨天已经给你开通了访问我们`repository`的权限，来我给你演示一遍怎么操作，首先你需要在本地选择一个位置作为你的开发环境，然后把我们的代码从代码服务器`clone`一份到本地，然后就可以开发了。

*小菜*：嗯，我知道了。

*老鸟*：你之前接触过代码管理工具么？

*小菜*：嗯，实习的时候用过`SVN`，`TFS`在学校的时候也了解过，基本的代码管理操作没问题。

*老鸟*：嗯，你试着自己做，有问题随时问我吧。

*小菜*：我现在就有一个问题，我看我们的开发环境中有一个`trunk`目录和`branch`目录，而这两个目录中的内容看着差不多，他们有什么区别呢？

*老鸟*：是这样的，我们的开发产品迭代较快，在同一个时间段内可能有多个人同时跟进多个需求，为了保证开放过程中代码安全和避免冲突，我们通过分支的方式来管理我们的代码。我们规定`trunk`为主干，该主干中的代码要尽可能保持是稳定、测试通过的，一旦代码合并到主干，则意味着逻辑功能都已经测试通过，但有可能存在由于合并过程中解决冲突而导致的新bug，我们发布到生产环境时也是从主干拿代码发布的。`branch`是从`trunk`中`fork`出来的一个分支，我们通常在此分支中开发和测试，当我们的逻辑功能测试完成后，需要把相应的代码`merge`到主干。

*小菜*：额！！好复杂啊，什么主干、分支的，有点晕！

*老鸟*：虽然听起来有些复杂，但实际操作起来会感觉简单许多，尤其在开发过程中你真正理解分支的重要性之后，看吧，不着急，在以后的工作中慢慢就熟悉了。

*小菜*：嗯，好，谢谢老鸟。

根据昨天老鸟的描述，小菜找到了对应需要修改的代码文件，又执行了一次`get latest version`操作从代码仓库获取了最新代码，然后小菜执行了`checkout`操作，使本地代码处于可编辑状态。小菜在心里再次思考了一下具体的实现方式，想了一下，然后发出一声冷笑，哼...这么简单，看我的，然后噼里啪啦的一阵狂敲，搞定！然后在本地做了一个测试发现没有问题，就把代码`checkin`了。按照老鸟的要求，小菜发了一封邮件给老鸟进行`codereview`。

*老鸟*：
看了一下小菜的代码，提出了一些修改意见，在`review`通过后，告诉小菜后天就可以提测了。

*小菜*：嗯，好的，谢谢老鸟。

*三天后*

*小菜*：
咦！！怎么会有bug呢，之前在本地测的时候正常啊，怎么到测试环境就出问题了呢，我还是先看下`history`(历史记录)，看这期间是不是还有其他同学也在修改这个文件。*小菜*通过历史记录看到昨天有一个提交记录，提交注释写的是`update`，我晕！这是谁啊，这么没素质，`update`了什么啊，看下到底是谁提交的，仔细看过之后发现是*攀哥*提交的，哎！这攀哥太缺德了，这边忙得不可开交，还要去看他的代码修改了那些地方，看代码多费时间啊，还是把他叫过来问下吧。攀哥，来一下。

*攀哥*：什么事情，这边正忙着呢！

*小菜*：
你修改的那个xx.js文件现在报错，我没找到原因，你快过来看下吧。

*攀哥*：不是有提交注释么？

*小菜*：你写的是`update`，不知道你`update`了哪些！

*攀哥*：
好，我来看下，*攀哥*来到小菜电脑前熟练的打开历史记录，看到注释中写的时`update`，他沉思了一会说*我也不记得修改哪些地方了*，我们`compare`一下代码吧。

*小菜*：*攀哥*V5。


通过对比工具*攀哥*找到了原因，是昨天自己重构了一个公共的方法，但有逻辑错误导致执行异常。

*攀哥*：你现在着急么？我那边正忙着呢，现在没时间处理这个。

*小菜*：着急！老鸟说了明天必须上线。

*攀哥*：这样吧，我现在我本地`fork`一个`bugfix`分支，然后你把代码`rollback`上一个稳定版继续你的流程吧。

*小菜*：也只能先这样了。

*时间又过了两天*

*攀哥*：
OK，搞定了，上次竟然把这个逻辑点考虑进去，NND！*小菜*上次那个bug搞定了，我现在要`merge`到`branch`中会影响到你么？

*小菜*：
嗯，不影响，我那个已经上线了，你合吧。

*攀哥*：
嗯，好的。
咦！竟然还有`conflict`，原来和小菜修改了同一行代码，为了安全起见还是把他喊过来一起看下。

在攀哥和小菜的一起努力下把这个冲突解`resolve`掉了。

*攀哥*：
好了*小菜*，没你事儿了，你回吧，我要提交代码了。

*小菜*：
嗯，没事，我等一会再回去，你提交吧。

*小菜*看到*攀哥*在提交代码时TFS提示需要填写提交注释，攀哥熟练的敲入了`update`，在*攀哥*点击提交的一刹那被*小菜*制止住了。

*小菜*：
*攀哥*咱不带这样的啊，又`update`，你的`update`是万能的、太强大了，我们都理解不了其中的含义。你还是具体描述一下本次提交修改的内容吧，免得下次又得对比代码看你修改了哪些。

*攀哥*：
白了一眼*小菜*，随即敲入了重构XX方法，然后快速点击了提交，生怕再次被*小菜*制止住。

好了，小故事讲完了。声明：本故事纯属虚构，如有巧合纯属雷同。

通过该故事的描述，我自己*捏造*了一个定义：源代码管理是指**通过特定的操作流程、规范以及相应的工具来约束、识别、跟踪开发过程，从而规避潜在的代码冲突、混乱和不可控制**。

##源代码管理历史
- 手动跟踪代码版本（20世纪60年代）
:	人们通过软盘拷贝传递代码的各个版本，并有专职的人员统一控制代码版本。
- 人们通过一些文件格式为一个文件保留多个版本（20世纪70年代）
- 每个人都可以检出自己的拷贝（1982）
:	在那个时候人们工作需要登录一台中央大型机并通过它一起工作，通过`RCS`可以让每个人都工作在相同的版本上，而且每个人都有自己的工作拷贝。
- 可以一次对多个文件进行版本控制（1990）
:	令人吃惊的是直到CVS出现以前，版本控制系统只支持单个文件。
- 两个人可以编辑同一个文件，并将他们的工作和并在一起（1990）
:	`CVS`提供了多人同时编辑一个文件，并将他们的修改没有错误的合并到一起而不造成其他问题。
- 可以在远程服务器上共享代码仓库（1994）
:	在1994年以前，人们大多数的工作环境和代码仓库在同一台机器上。直到1994年TCP/IP协议的引入才真正实现了通过访问远程服务器共享代码仓库。
- 免费的开源版本控制主机服务（1999）
:	SourceForge大家都听说，便是在这一年推出的。SourceForge是一套合作式软件开发管理系统，是开源软件开发者进行开发管理的集中场所。当前比较流程的版本控制主机服务除了SourceForge之外还有Google Code以及当下最火的Github。
- 没有主代码库，你可以向所有人发布（2003）
:	21世纪的头10年，有一股将版本控制实现完全分布式的潮流。2003年Monotone问世，2005年另外两个重量级分布式源代码管理系统问世Mercurial、Git。
- 当你检出一个fork，大家都可以看到（2008）
:	Github问世

##源代码管理工具概述
- RCS(Revision Control System)
:	修订控制系统，上世纪七八十年代被广泛使用的源代码管理工具。
- VSS(Visual SourceSafe)
:	微软的源代码管理工具，曾经被默认集成到Visual Studio 2008以前的版本中，从Visual Studio 2008开始集成Team Foundation Server。VSS现在基本已被淘汰。
- CVS(Concurrent Version System)
:	协作版本控制系统，也被称为并发版本控制系统。该系统1990年被推出并一度成为主流的版本控制系统。但CVS还有很多缺点，比如：不支持原子操作、不能重命名文件、支持文本文件等。目前CVS已逐渐被下面要介绍的SVN取代。
- SVN(Subversion)
:	2000年开始筹划，2001年问世，是一个开放源代码的版本控制系统，相比于RCS、CVS它采用了分支管理系统，它的设计目标就是取代CVS。
- TFS(Team Foundation System)
:	TFS全称是团队工作流引擎，与Visual Studio绑定在一起，源代码管理只是其中的一部分功能，除源代码管理功能外还包括bug跟踪、开发管理等功能。功能强大，不够灵活。
- Monotone
:	开放源代码的分布式源代码管理系统，由C++实现，2003年问世，接下来介绍的`Git`早期版本就是在Monotone的基础上改写的。
- Git
:	2005年问世，目前最火的分布式代码管理系统。Git设计的最初目的是Linux之父用来取代BitKeeper来管理Linux内核用的。
- Mercurial
:	跨平台的分布式代码管理系统，主要由Python语言实现，也包括部分C语言实现的基础模块。Mercurial最开始的主要运行平台是Linux现已被移植到windows、Mac OS以及大多数类Unix系统。
- BitKeeper
:	BitKeeper也是分布式代码管理系统，但它是商业版的，它的主要竞争对手就是Git和Mercurial。

上述9个工具都是过去、现在广为人知的源代码管理工具，他们有些已经绝迹了，有些已经不再那么辉煌了，作为程序员的我们要感谢这些前辈或者先烈们对源代码管理领域做出的贡献。

从上面的描述中大家也看到了，从代码仓库的存储上来说，源代码管理工具可分为集中式源代码管理模式和分布式源代码管理模式。

集中式代码管理模式会有一个中央代码仓库，软件开发人员可以从代码仓库将代码`clone`到本地进行开发和修改，修改完成后再将变更信息`checkin`到代码仓库。

分布式代码管理模式会有多个代码仓库节点，和集中式代码管理模式有个明显的差别是 *在集中式代码管理模式中从`开发区`修改的代码直接提交到了代码仓库；而分布式代码管理模式中增加了`缓冲区`，从`开发区`提交更改到`缓冲区`，然后再从`缓冲区`将代码`push`到`代码仓库`* 。有了缓冲区就为分布式代码管理系统提供了`离线`管理代码的可能，向缓冲区提交的代码会有完整的代码变更记录以及回滚、撤销操作。

下面两个图例分别展示了集中式代码管理模式和分布式代码管理模式的区别：

**集中式代码管理模式**

![集中式代码管理模式](https://cloud.githubusercontent.com/assets/654747/2560908/697a865c-b7ec-11e3-8f82-8149fa0b31fe.png)

**分布式代码管理模式**

![分布式代码管理模式](https://cloud.githubusercontent.com/assets/654747/2560907/694c7758-b7ec-11e3-9608-bc2561c91749.png)

集中式代码管理系统有：
:	VSS、CVS、SVN以及TFS内置的代码管理工具

分布式代码管理系统有：
:	Monotone、Git、Mercurial、BitKeeper

分布式代码管理模式目前炒的很热，但集中式也有其其优点，应该更多从实际情况考虑使用哪种模式。比如：*分布式代码管理模式比较适合开源项目，或跨地域团队协作项目；而集中式在公司内部的传统项目中足以满足需求*。

##源代码管理的最佳实践
- 每次提交只做一个修改
:	如果你在一次提交中修复了#230，#233两个bug，重构了一个工具类，界面上增加了两个按钮，还把整个项目中的tab改成2个空格，那么基本上没有人能review本次提交，只有你自己才知道修改了那些地方，而且一周以后可能连你自己都忘了修改了哪些地方。要是一周以后你发现原来那次提交导致了一个严重的bug，那你就完蛋了，很有可能之前一周的努力都白费了。
:	所以说，我们要在每次提交中只做一个修改，对于若何才算是`一个修改`没有硬性或者既定规定，或者它是一个逻辑上最小的单元，如果你能用一个子句，并且不用“和”这个字来描述你所做的事情，那基本上是做到了。
- 每次提交要包含完整的修改
:	如果一个修改分布到几次提交里面，那么这个修改也很难review的。通常这是因为在同一时间解决太多问题导致，如果你吃不了那么多，却啃了那么多，那么在你想保存其中的某些修改的时候，你会发现大部分的修改都是未完成的。同一时间处理太多问题会导致你最终需要花费很长时间才能提交完整的修改。
- 写好注释，说明你修改了什么
:	类似 *修复*、*提交*、*update*、*同上*...这类提交信息没有包含任何有用的信息。如果别人想看看版本历史，像这样的提交信息只会逼他们去看完所有修改的代码，就像我在上面的故事中讲到的，看代码是很费时费力的，写一个简短的且表达不清晰的提交注释，可能省了你一分钟的时间，但却浪费了其他人几个小时。
一个好的提交信息可以让看的人清楚哪一部分的代码被修改了，是怎么修改的，他们也不需要去看你的代码。
- 提交代码时检查你的修改，看清楚提交的修改
:	提交代码到代码仓库很简单，但要明确的知道你本次提交的文件修改了那些内容以及哪些文件会被提交，在提交对现有文件修改时，最好通过对比工具对比一下自己修改了那些地方，是不是将debug信息也提交上去了，或者原本要注释掉的代码发现没有注释等等。在提交文件列表中看清楚提交的文件是不是自己预期的，会不会把一些临时的测试文件给带到代码仓库。这样可以保持提交历史记录的整洁，减少对代码库中代码的污染。
- 合并分支时要清楚的知道即将合并哪些代码
:	一般我们在分支之间合并代码时都会选择分支中的最新代码来合并，但建议你合并时通过`changeset`查看一下变更集内容，通过提交注释查看最新的代码是不是你要合并的代码，很有可能会把一些未测试通过，或其他不希望合并的代码合并进去。
- 合并代码时不要忽略每一个冲突提示，请认真对待冲突
:	多人协作的团队中在合并代码时可能会出现冲突的可能，当代码管理工具提示你存在冲突时请一定要认真对待，现代的版本管理工具一般会智能的处理一些冲突，但当工具解决不了时，请仔细查看冲突，然后谨慎的调整解决，很有可能这个冲突会导致代码执行异常，或者某个判断逻辑丢失了等等。

##常用术语
- VCS(Version Control System)
- RCS(Revision Control System)
- SCM(Source Code Management)
- Changeset
- Revision
- History
- Repositroy
- Commit
- Checkout
- Checkin
- Conflict
- Branch
- Tag
- Distributed
- Concentrated

##参考资料
- 一个优秀的提交应该包含什么
:	[http://blog.jobbole.com/42515/](http://blog.jobbole.com/42515/)
- Git
:	[http://git-scm.com/](http://git-scm.com/)
:	[http://git-scm.com/book/zh](http://git-scm.com/book/zh)
:	[http://zh.wikipedia.org/zh/Git](http://zh.wikipedia.org/zh/Git)
:	[http://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/](http://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/)
- 分支
:	[http://www.ituring.com.cn/article/56870](http://www.ituring.com.cn/article/56870)
:	[Git分支的最佳实践](http://jiongks.name/blog/a-successful-git-branching-model/)
- Mercurial
:	[使用Mercurial管理代码](http://www.ibm.com/developerworks/cn/aix/library/au-mercurial/)
:	[wiki](http://zh.wikipedia.org/wiki/Mercurial)
- Subversion
:	[使用SVN管理代码](https://www.ibm.com/developerworks/cn/java/j-subversion/)
:	[wiki](http://zh.wikipedia.org/zh-cn/Subversion)
